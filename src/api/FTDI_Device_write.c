#include <stdlib.h>
#include <string.h>

#include "api/FTDI_Device.h"
#include "ftd2xx.h"
#include "utils.h"

typedef struct {
  // Node-API variables
  napi_async_work async_work;
  napi_deferred deferred;

  // Data passed to execute_callback
  device_instance_data_t* instance_data;
  uint32_t tx_bytes_to_write;
  uint8_t* tx_buffer;

  // Data passed to complete_callback
  FT_STATUS ftStatus;
  DWORD tx_bytes_written;

} async_data_t;


// This function runs on a worker thread.
// It has no access to the JavaScript. Only FTDI functions are called here.
static void execute_callback(napi_env env, void* data) {
  (void) env; // hide unused parameter warning
  async_data_t* async_data = (async_data_t*) data;

  // Write to FTDI device (this is a blocking function)
  async_data->ftStatus = FT_Write(async_data->instance_data->ftHandle, async_data->tx_buffer,
                                  async_data->tx_bytes_to_write, &(async_data->tx_bytes_written));
}


// This function runs on the main thread after `execute_callback` exits.
// JavaScript functions are called here to convert data generated by FTDI.
static void complete_callback(napi_env env, napi_status status, void* data) {
  (void) status; // hide unused parameter warning
  async_data_t* async_data = (async_data_t*) data;

  // Manage FTDI error if any
  utils_check(async_data->ftStatus == FT_IO_ERROR, "USB was lost during write operation", ERR_USBLOST);
  utils_check(FT_|async_data->ftStatus); // manage other errors

  // Resolve the JavaScript `Promise`:
  bool is_exception_pending;
  napi_is_exception_pending(env, &is_exception_pending);
  if(is_exception_pending) {
    // If an exception is pending, clear it to prevent Node.js from crashing
    napi_value error;
    napi_get_and_clear_last_exception(env, &error);

    // Instead reject the JavaScript `Promise` with the error
    napi_reject_deferred(env, async_data->deferred, error);

  } else {
    // Else resolve the JavaScript `Promise` with the return value
    napi_value nb_bytes_written;
    napi_create_uint32(env, async_data->tx_bytes_written, &nb_bytes_written);
    napi_resolve_deferred(env, async_data->deferred, nb_bytes_written);
  }

  // Clean up the work item associated with this run
  napi_delete_async_work(env, async_data->async_work);

  // Free async instance data structure
  free(async_data->tx_buffer);
  free(async_data);
}


// Create a deferred JavaScript `Promise` and an async queue work item
napi_value device_write(napi_env env, napi_callback_info info) {
  // Get JavaScript `this` corresponding to this instance of the class and `argc`/`argv` passed to the function
  #define NB_ARGS 1 // number of expected arguments
  size_t argc = NB_ARGS; // size of the argv buffer
  napi_value this_arg, argv[NB_ARGS];
  utils_check(napi_get_cb_info(env, info, &argc, argv, &this_arg, NULL));
  if(utils_check(argc < NB_ARGS, "Missing argument", ERR_MISSARG)) return NULL;

  // Check that the data argument is a TypedArray
  bool is_typedarray;
  utils_check(napi_is_typedarray(env, argv[0], &is_typedarray));
  if(utils_check(is_typedarray == false, "The data to write must be a TypedArray", ERR_WRONGARG)) return NULL;

  // Allocate memory for async instance data structure
  async_data_t* async_data = malloc(sizeof(async_data_t));
  if(utils_check(async_data == NULL, "Malloc failed", ERR_MALLOC)) return NULL;

  // Allocate memory for TX buffer
  void* data;
  napi_value array_buffer;
  size_t byte_offset, byte_length;
  utils_check(napi_get_typedarray_info(env, argv[0], NULL, NULL, NULL, &array_buffer, &byte_offset));
  utils_check(napi_get_arraybuffer_info(env, array_buffer, &data, &byte_length));
  byte_length -= byte_offset;
  async_data->tx_buffer = malloc(byte_length);
  if(utils_check(async_data->tx_buffer == NULL, "Malloc failed", ERR_MALLOC)) return NULL;

  // Copy TX buffer
  memcpy(async_data->tx_buffer, (uint8_t*)data + byte_offset, byte_length);

  // Set the number of bytes to be written
  async_data->tx_bytes_to_write = (uint32_t)byte_length;

  // Get the class instance data containing FTDI device handle
  utils_check(napi_unwrap(env, this_arg, (void**)&(async_data->instance_data)));

  // Create a deferred `Promise` which we will resolve at the completion of the work
  napi_value promise;
  utils_check(napi_create_promise(env, &(async_data->deferred), &promise));

  // Create an async work item, passing in the addon data, which will give the worker thread access to the `Promise`
  napi_value name;
  utils_check(napi_create_string_utf8(env, "deviceWrite", NAPI_AUTO_LENGTH, &name));
  utils_check(napi_create_async_work(env, NULL, name, execute_callback, complete_callback, async_data, &(async_data->async_work)));

  // Queue the work item for execution
  utils_check(napi_queue_async_work(env, async_data->async_work));

  // This causes created `Promise` to be returned to JavaScript
  return promise;
}
